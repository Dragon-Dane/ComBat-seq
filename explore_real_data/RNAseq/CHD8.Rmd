---
title: "Exploration of real bulk RNA-seq datasets"
subtitle: "ReCount data for CHD8 regulatory network (SRP047233)"
author: Yuqing Zhang
date: "`r Sys.Date()`"
output:
  html_notebook:
    theme: united
    toc: yes
bibliography: refs.bib
---

## Introduction

ReCount is a public database of pre-processed RNA-seq gene count data. The SVAseq paper [@leek2014svaseq] used 2 studies with gene measurements in two separate Hapmap populations, and looked for differentially expressed genes between genders in the two studies combined. Exploration of the same ReCount data used in SVAseq are summarized in a separate file (svaseq_recount).

Here, I searched the ReCount database with the keyword "batch", and found a few datasets with abstracts containing this word (which means that the dataset potentially has batch effect). One of them is SRP047233 [@sugathan2014chd8]. This dataset aims to investigate the impact of decreased CHD8 expression on the expression of genes in downstream (CHD8-regulated) network. Truncating mutation of CHD8 is an important risk factor for autism spectrum disorder (ASD).

### Overall design

RNA-seq in NPCs treated with shRNAs targeting CHD8. For controls, NPCs were treated with shRNAs targeting GFP and LacZ. Infection and sequencing was carried out in two separate batches, with one GFP and one LacZ sample in each batch. All samples were sequenced in two technical replicates. (https://trace.ncbi.nlm.nih.gov/Traces/sra/?study=SRP047233)


### Download data & basic info

First, we download the data using the recount R package as shown in its vignette. Note that we use the read_counts() function instead of scale_counts() to convert the provided base pair counts to read counts, so that we get the raw counts without normalization.

```{r, echo=FALSE, results='hide'}
rm(list=ls())
output_dir <- "~/Google Drive/ComBat_seq/real_data_example/RNAseq/CHD8"
sapply(c("recount", "DESeq2", "edgeR", "dendextend", "ggplot2", "reshape2", "gridExtra", "scales", "ggdendro"), 
       require, character.only=TRUE)


####  Load data
# abstract_search('batch')$project
study_SRP <- "SRP047233"
download_study(study_SRP)
load(file.path(study_SRP, 'rse_gene.Rdata'))
meta_info <- as.data.frame(colData(rse_gene))

## Obtain (unnormalized) read counts from provided base pair coverage counts
rse_gene <- read_counts(rse_gene, round=TRUE) #scale_counts(rse_gene)  

## Batch indicator
batch <- sapply(meta_info$characteristics, function(s){s[grep("batch",s)]})
batch <- as.factor(batch)
batch <- sapply(batch, function(b){return(which(levels(batch)==b))})

## Condition indicator
group <- rep(NA, nrow(meta_info))
group[grep("CHD8", meta_info$title)] <- "CHD8"
group[grep("GFP", meta_info$title)] <- "GFP"
group[grep("LacZ", meta_info$title)] <- "LacZ"
group_num <- rep(0, nrow(meta_info)); group_num[group=="CHD8"] <- 1
#group <- sapply(meta_info$characteristics, function(s){s[grep("shRNA target gene",s)]})
  
## Add batch and condition in meta info
colData(rse_gene)$batch <- as.factor(batch)
colData(rse_gene)$condition <- as.factor(group)
colData(rse_gene)$condition_bi <- as.factor(group_num)

##  Save data in desired format
save(rse_gene, file=file.path(output_dir, 'rse_gene.Rdata'))
unlink(file.path(study_SRP), recursive=TRUE)
```

After downloading the data, we calculate a few basic statistics of the dataset.

```{r, echo=FALSE}
cat("######  Samples  #######\n")
cat("- Total number of samples:\n")
print(ncol(rse_gene))

cat("\n- Number of samples in condition groups:\n")
print(table(group))

cat("\n- Number of samples in batches:\n")
print(table(batch))
cat("In batch 1:")
print(table(group[batch==1]))
cat("In batch 2:")
print(table(group[batch==2]))

cat("\n\n######  Genes  #######\n")
cat("- Total number of genes:\n")
print(nrow(rse_gene))

cat("\n- Number of genes with 0 counts:\n")
gene_row_with_zeros <- apply(assay(rse_gene, "counts"), 1, function(x){any(x==0)})
print(c(sum(gene_row_with_zeros), round(sum(gene_row_with_zeros)/nrow(rse_gene),3)))
cat("\n- Number of genes with ONLY 0s:\n")
gene_all_zeros <- apply(assay(rse_gene, "counts"), 1, function(x){all(x==0)})
print(c(sum(gene_all_zeros), round(sum(gene_all_zeros)/nrow(rse_gene),3)))

rm(gene_all_zeros, gene_row_with_zeros)
```

For the following analysis, **we remove genes with all-zero values across all samples**. 

```{r}
## Remove genes with all 0 counts
rse_gene <- rse_gene[apply(assay(rse_gene, "counts"), 1, function(x){!all(x==0)}), ]
print(dim(rse_gene))
```

The figure below shows distribution of percentages of zero counts for the remaining genes (each data point represents a gene, i.e., how many zeros are there in each gene).

```{r, echo=FALSE}
n_zeros_in_genes <- apply(assay(rse_gene, "counts"), 1, function(x){length(which(x==0))})
percent_zeros_in_genes <- n_zeros_in_genes / ncol(rse_gene)
percent_zeros_df <- data.frame(genes=rownames(rse_gene), value=percent_zeros_in_genes)
ggplot(percent_zeros_df, aes(0, value)) + 
      geom_violin() +
      #geom_boxplot(width=0.15) +
      coord_flip() +
      geom_text(aes(label=round(median(percent_zeros_df$value),2), x=0.1, y=median(percent_zeros_df$value))) +
      labs(y="% Zeros", title="Proportion of zeros across samples for the remaining genes") +
      theme(axis.title.y=element_blank())
rm(n_zeros_in_genes, percent_zeros_in_genes, percent_zeros_df)
```



## Existence of batch effect {.tabset}

We first visualize the data using PCA and hierarchical clustering, to see if there is any batch effect in the dataset. Based on these plots, I believe there exists a certain level of batch effect in the data, as samples cluster more by batch than by biological condition.

### PCA

```{r, echo=FALSE, fig.height=2, fig.width=5}
pca_obj <- plotPCA(DESeqTransform(rse_gene), intgroup=c("batch", "condition_bi")) 
colnames(pca_obj$data)[5] <- "cond"
p_batch <- ggplot(pca_obj$data, aes(x=PC1, y=PC2, color=batch)) +
  geom_point() + 
  scale_color_manual(values=c('#E69F00', '#56B4E9'))+
  labs(x=sprintf("PC1: %s Variance", percent(pca_obj$plot_env$percentVar[1])),
       y=sprintf("PC2: %s Variance", percent(pca_obj$plot_env$percentVar[2])),
       title="PCA: samples colored by Batch")
p_cond <- ggplot(pca_obj$data, aes(x=PC1, y=PC2, color=cond)) +
  geom_point() + 
  labs(x=sprintf("PC1: %s Variance", percent(pca_obj$plot_env$percentVar[1])),
       y=sprintf("PC2: %s Variance", percent(pca_obj$plot_env$percentVar[2])),
       title="PCA: samples colored by Condition")
grid.arrange(p_batch, p_cond, ncol=2)
```

### Dendrograms

```{r, echo=FALSE, fig.height=3, fig.width=5}
counts_norm <- scale(t(assay(rse_gene,"counts")), center=TRUE, scale=TRUE)
hc <- hclust(dist(counts_norm))
dend <- as.dendrogram(hc)
ddata <- dendro_data(dend, type = "rectangle")

meta_info <- data.frame(colData(rse_gene)[, c("batch", "condition_bi")], sample=colnames(rse_gene))
colnames(meta_info)[2] <- "cond"
tmp <- merge(x=ddata$labels, y=meta_info, by.x="label", by.y="sample")

pd_batch <- ggplot(segment(ddata)) + 
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + 
  coord_flip() + scale_y_reverse() +
  scale_color_manual(values=c('#E69F00', '#56B4E9')) +
  geom_text(data=tmp, aes(label=sapply(as.character(tmp$label), function(s){substr(s,nchar(s)-2,nchar(s))}), 
                          x=x, y=-10, colour=batch)) +
  labs(x="", y="", title="Clustering: samples colored by Batch")
pd_cond <- ggplot(segment(ddata)) + 
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + 
  coord_flip() + scale_y_reverse() +
  geom_text(data=tmp, aes(label=sapply(as.character(tmp$label), function(s){substr(s,nchar(s)-2,nchar(s))}), 
                          x=x, y=-10, colour=cond)) +
  labs(x="", y="", title="Clustering: samples colored by Condition")
grid.arrange(pd_batch, pd_cond, ncol=2)

rm(counts_norm, ddata, dend, hc, p_batch, p_cond, pca_obj, pd_batch, pd_cond, tmp)
```


## Library size

Next, we take a look at the observed library sizes of samples, and to see if there is a difference in library size across batches.

```{r, echo=FALSE}
###  Distribution of library size
lib_sizes <- colSums(assay(rse_gene, "counts"))
cat("Range of observed library sizes across samples:\n")
print(scientific(range(lib_sizes)))
```


```{r, echo=FALSE, fig.height=2, fig.width=4}
lib_sizes_df <- data.frame(lib_sizes=lib_sizes, batch=as.factor(batch))

# overall sample library sizes
plib1 <- ggplot(lib_sizes_df, aes(x=lib_sizes)) + 
  geom_histogram(bins=round(ncol(rse_gene)/5)) +
  geom_vline(aes(xintercept=mean(lib_sizes)), color="red", linetype="dashed", size=1) +
  annotate(geom="text", x=mean(lib_sizes), y=max(hist(lib_sizes, plot=FALSE)$counts)+1, 
           label=scientific(mean(lib_sizes)), color="red") +
  labs(x="Library sizes in samples", y="Number of samples", 
       title="Distribution of observed library sizes") 

# boxplot comparing distribution of library size across batches
plib2 <- ggplot(lib_sizes_df, aes(x=batch, y=lib_sizes, fill=batch)) + 
  geom_boxplot() +
  labs(x="", y="Library sizes", title="Compare library sizes across batch") 

grid.arrange(plib1, plib2, ncol=2)

rm(plib1, plib2)
```


## Gene expression distribution

Our next step is to interrogate the gene expression distributions. 

We first simply plot the counts, CPM, and log2CPM of 10 randomly chosen genes in the dataset. These figures are stored under directory specified by output_dir.  

```{r, echo=FALSE, results='hide'}
if(!dir.exists(file.path(output_dir, "randGplots"))){dir.create(file.path(output_dir, "randGplots"))}
set.seed(123)
N_sel <- 10
chosen_id <- sample(1:nrow(rse_gene), N_sel, replace=FALSE)

cts_subset <- assay(rse_gene, "counts")[chosen_id, ]
cpm_subset <- cpm(assay(rse_gene, "counts"), log=FALSE)[chosen_id, ]
logCPM_subset <- cpm(assay(rse_gene, "counts"), log=TRUE)[chosen_id, ]
data_lst <- list(Counts=cts_subset, CPM=cpm_subset, log2CPM=logCPM_subset)

void <- mapply(function(dat, dat_name, meta_info){
  for(i in 1:nrow(dat)){
    # prepare data frame
    curr_df <- data.frame(samples=colnames(dat), value=dat[i, ])
    curr_df <- merge(x=curr_df, y=meta_info, by.x="samples", by.y="sample")
    
    # scatter plot for i-th gene
    p_scatter <- ggplot(curr_df, aes(x=samples, y=value, color=batch, shape=cond)) +
      geom_point() +
      labs(x="Samples", y=dat_name, title=rownames(dat)[i]) +
      theme(axis.text.x=element_blank())
    
    # violin plot for i-th gene
    p_violin <- ggplot(curr_df, aes(0, value)) + 
      geom_violin() +
      geom_boxplot(width=0.2) +
      coord_flip() +
      geom_text(aes(label=as.integer(median(curr_df$value)), x=0.12, y=median(curr_df$value))) +
      labs(y=dat_name, title=sprintf("All samples, %s", rownames(dat)[i])) +
      theme(axis.title.y=element_blank())
    
    # violin plot group by batch
    medians_batch <- aggregate(value ~ batch, data=curr_df, FUN=median)
    p_violin_batch <- ggplot(curr_df, aes(x=batch, y=value, color=batch)) + 
      geom_violin() +
      geom_boxplot(width=0.2) +
      coord_flip() +
      scale_color_manual(values=c('#E69F00', '#56B4E9')) +
      geom_text(data=medians_batch, 
                aes(label=round(medians_batch$value,2), x=as.numeric(as.character(medians_batch$batch))+0.12,
                    y=as.numeric(as.character(medians_batch$value)))) +
      labs(y=dat_name, title=sprintf("In batches, %s", rownames(dat)[i])) +
      theme(axis.title.y=element_blank())
    
    # violin plot group by condition
    medians_cond <- aggregate(value ~ cond, data=curr_df, FUN=median)
    p_violin_cond <- ggplot(curr_df, aes(x=cond, y=value, color=cond)) + 
      geom_violin() +
      geom_boxplot(width=0.2) +
      coord_flip() +
      geom_text(data=medians_cond,
                aes(label=round(medians_cond$value,2), x=as.numeric(as.character(medians_cond$cond))+1.12, 
                    y=as.numeric(as.character(medians_cond$value)))) +
      labs(y=dat_name, title=sprintf("In condition groups, %s", rownames(dat)[i])) +
      theme(axis.title.y=element_blank())
    
    # output plot
    png(sprintf("%s/%s_gene%s.png", file.path(output_dir, "randGplots"), dat_name, i),
        width=10, height=8, units="in", res=300)
    grid.arrange(p_scatter, p_violin, p_violin_batch, p_violin_cond, nrow=2, ncol=2)
    dev.off()
  }
}, dat=data_lst, dat_name=names(data_lst), meta_info=list(meta_info,meta_info,meta_info))

rm(cts_subset, cpm_subset, logCPM_subset, lib_sizes, lib_sizes_df, chosen_id, data_lst, void, N_sel)
```


### Fold changes in mean {.tabset}

We then use edgeR to perform differential expression analysis, and calculate (log-) fold changes of all genes between condition groups and batches.

#### Change WRT condition

To rule out the impact of batch effect, we limit our DE analysis WRT biological condition in one of the batches. Here we specify the batch to be **Batch 1**.

```{r, results="hide"}
####  Differential genes relative to biological condition 
####  (within batch 1 / batch specified by 'test_batch')
test_batch <- 1
counts_batch <- assay(rse_gene,"counts")[, batch==test_batch]
cond_batch <- group_num[batch==test_batch]

y <- DGEList(counts=counts_batch, group=as.factor(cond_batch))
y <- calcNormFactors(y, method="TMM")
design <- model.matrix(~as.factor(cond_batch))
y <- estimateDisp(y, design)
fit <- glmQLFit(y, design)
qlf <- glmQLFTest(fit, coef=2)
de_res <- topTags(qlf, n=nrow(rse_gene))
 
up_genes <- rownames(de_res)[de_res$table$logFC >= 0]  # all up-regulated genes
head_up_genes <- head(up_genes, n=50)  # top-50 up-regulated genes
tail_up_genes <- tail(up_genes, n=50)  # 50 least up-regulated genes

down_genes <- rownames(de_res)[de_res$table$logFC < 0]  # all down-regulated genes
head_down_genes <- head(down_genes, n=50)  # top-50 down-regulated genes
tail_down_genes <- tail(down_genes, n=50)  # 50 least down-regulated genes
```


```{r, echo=FALSE}
# changes in terms of mean
cat("\n ######  Changes in terms of mean gene counts  ######\n")
mean_cts_mat <- matrix(NA, nrow=2, ncol=3, 
                       dimnames=list(c("Controls", "Cases"), c("top50 up", "top50 down", "100 least DE")))
mean_cts_mat["Controls", "top50 up"] <- mean(counts_batch[head_up_genes, cond_batch==0])
mean_cts_mat["Cases", "top50 up"] <- mean(counts_batch[head_up_genes, cond_batch==1])
mean_cts_mat["Controls", "top50 down"] <- mean(counts_batch[head_down_genes, cond_batch==0])
mean_cts_mat["Cases", "top50 down"] <- mean(counts_batch[head_down_genes, cond_batch==1])
mean_cts_mat["Controls", "100 least DE"] <- mean(counts_batch[c(tail_up_genes, tail_down_genes), cond_batch==0])
mean_cts_mat["Cases", "100 least DE"] <- mean(counts_batch[c(tail_up_genes, tail_down_genes), cond_batch==1])
print(round(mean_cts_mat,2))

# changes in terms of fold change
cat("\n ######  Range of fold change across biological conditions  ######\n")
FC_mat <- matrix(NA, nrow=2, ncol=3, 
                       dimnames=list(c("min FC", "max FC"), c("top50 up", "top50 down", "100 least DE")))
FC_mat[, "top50 up"] <- range(exp(de_res$table[head_up_genes, "logFC"]))
FC_mat[, "top50 down"] <- range(exp(de_res$table[head_down_genes, "logFC"]))
FC_mat[, "100 least DE"] <- range(exp(de_res$table[c(tail_up_genes, tail_down_genes), "logFC"]))
print(round(FC_mat,3))

rm(cond_batch, counts_batch, up_genes, head_up_genes, tail_up_genes, 
   down_genes, head_down_genes, tail_down_genes, y, design, fit, qlf, de_res, mean_cts_mat, FC_mat)
```


#### Change WRT batch

We are also interested to see how the mean gene counts change across batches (i.e. **degree of mean batch effect**). To explore this mean batch effect, we perform DE WRT batch. To rule out the impact of biological condition, we perform this analysis within **control** samples only. Note that this DE is not true DE - it's testing if there is a significant mean difference between two batches. Some genes will not be different in mean, while some will. Which means that batch doesn't affect all genes in the same way.

```{r, results="hide"}
####  Differential genes relative to batch 
####  (within condition 0 / condition specified by 'test_cond')
test_cond <- 0
counts_cond <- assay(rse_gene,"counts")[, group_num==test_cond]
batch_cond <- batch[group_num==test_cond]

y <- DGEList(counts=counts_cond, group=as.factor(batch_cond))
y <- calcNormFactors(y)
design <- model.matrix(~as.factor(batch_cond))
y <- estimateDisp(y, design)
fit <- glmQLFit(y, design)
qlf <- glmQLFTest(fit, coef=2)
de_res <- topTags(qlf, n=nrow(rse_gene))

up_genes <- rownames(de_res)[de_res$table$logFC >= 0]  # all up-regulated genes
head_up_genes <- head(up_genes, n=50)  # top-50 up-regulated genes
tail_up_genes <- tail(up_genes, n=50)  # 50 least up-regulated genes

down_genes <- rownames(de_res)[de_res$table$logFC < 0]  # all down-regulated genes
head_down_genes <- head(down_genes, n=50)  # top-50 down-regulated genes
tail_down_genes <- tail(down_genes, n=50)  # 50 least down-regulated genes
```

```{r, echo=FALSE}
# changes in terms of mean
cat("\n ######  Batch differences in terms of mean gene counts  ######\n")
mean_cts_mat <- matrix(NA, nrow=2, ncol=3, 
                       dimnames=list(c("Batch1", "Batch2"), c("top50 up", "top50 down", "100 least DE")))
mean_cts_mat["Batch1", "top50 up"] <- mean(counts_cond[head_up_genes, batch_cond==1])
mean_cts_mat["Batch2", "top50 up"] <- mean(counts_cond[head_up_genes, batch_cond==2])
mean_cts_mat["Batch1", "top50 down"] <- mean(counts_cond[head_down_genes, batch_cond==1])
mean_cts_mat["Batch2", "top50 down"] <- mean(counts_cond[head_down_genes, batch_cond==2])
mean_cts_mat["Batch1", "100 least DE"] <- mean(counts_cond[c(tail_up_genes, tail_down_genes), batch_cond==1])
mean_cts_mat["Batch2", "100 least DE"] <- mean(counts_cond[c(tail_up_genes, tail_down_genes), batch_cond==2])
print(round(mean_cts_mat,2))

# changes in terms of fold change
cat("\n ######  Range of fold change across biological conditions  ######\n")
cat("- All genes:\n")
cat(round(range(abs(de_res$table$logFC)), 3)) 

cat("\n- Top genes:\n")
FC_mat <- matrix(NA, nrow=2, ncol=3, 
                       dimnames=list(c("min FC", "max FC"), c("top50 up", "top50 down", "100 least DE")))
FC_mat[, "top50 up"] <- range(exp(de_res$table[head_up_genes, "logFC"]))
FC_mat[, "top50 down"] <- range(exp(de_res$table[head_down_genes, "logFC"]))
FC_mat[, "100 least DE"] <- range(exp(de_res$table[c(tail_up_genes, tail_down_genes), "logFC"]))
print(round(FC_mat,3))

rm(batch_cond, counts_cond, up_genes, head_up_genes, tail_up_genes, 
   down_genes, head_down_genes, tail_down_genes, y, design, fit, qlf, de_res, mean_cts_mat, FC_mat)
```


### Dispersion

Aside from mean gene counts, we are also interested in dispersions in the two batches. We plot the gene-wise dispersion estimates from edgeR:

```{r, echo=FALSE}
####  Dispersion differences across batch 1 and 2
y_batch1 <- DGEList(counts=assay(rse_gene,"counts")[, batch==1], group=as.factor(group_num[batch==1]))
y_batch1 <- calcNormFactors(y_batch1)
design_batch1 <- model.matrix(~as.factor(group_num[batch==1]))
y_batch1 <- estimateDisp(y_batch1, design_batch1)

y_batch2 <- DGEList(counts=assay(rse_gene,"counts")[, batch==2], group=as.factor(group_num[batch==2]))
y_batch2 <- calcNormFactors(y_batch2)
design_batch2 <- model.matrix(~as.factor(group_num[batch==2]))
y_batch2 <- estimateDisp(y_batch2, design_batch2)

disp_df <- data.frame(batch1=y_batch1$tagwise.dispersion, batch2=y_batch2$tagwise.dispersion)

cat("####  Average dispersion estimates from the two batches  ####\n")
cat("- Mean:\n")
print(round(colMeans(disp_df), 3))
cat("- Median:\n")
print(round(apply(disp_df, 2, median), 3))
```

```{r, echo=FALSE, message=FALSE}
disp_df_mlt <- melt(disp_df)
ggplot(disp_df_mlt, aes(x=variable, y=value)) +
  geom_violin() +
  labs(x="Batch", y="Estimated gene-wise dispersion", 
       title="Comparison of estimated dispersion across batches") +
  stat_summary(fun.y=mean, colour="darkred", geom="point", shape=18, size=3) +
  scale_y_continuous(limits=c(0, 1))
```


## Summary

+ There exists a certain level of batch effect in this dataset.


## Session info 

```{r, echo=FALSE}
sessionInfo()
```


## References
