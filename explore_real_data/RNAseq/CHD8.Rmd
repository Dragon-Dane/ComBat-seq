---
title: "Exploration of real bulk RNA-seq datasets"
subtitle: "ReCount data for CHD8 regulatory network (SRP047233)"
author: Yuqing Zhang
date: "`r Sys.Date()`"
output:
  html_notebook:
    theme: united
    toc: yes
bibliography: refs.bib
---

## Introduction

ReCount is a public database of pre-processed RNA-seq gene count data [@collado2017reproducible]. The SVAseq paper [@leek2014svaseq] used 2 studies from ReCount with gene measurements in two separate Hapmap populations, and looked for differentially expressed genes between genders in the two studies combined. However, the sample information for the Hapmap dataset is no longer available as NCBI took down Hapmap (https://www.ncbi.nlm.nih.gov/variation/news/NCBI_retiring_HapMap/).

Here, I searched the ReCount database with the keyword "batch", and found a few datasets with abstracts containing this word (which means that the dataset potentially has batch effect). One of them is SRP047233 [@sugathan2014chd8]. This dataset aims to investigate the impact of decreased CHD8 expression on the expression of genes in downstream (CHD8-regulated) network. Truncating mutation of CHD8 is an important risk factor for autism spectrum disorder (ASD).


### Overall design

RNA-seq in NPCs treated with shRNAs targeting CHD8. For controls, NPCs were treated with shRNAs targeting GFP and LacZ. Infection and sequencing was carried out in 2 separate batches, with one GFP and one LacZ sample in each batch. All samples were sequenced in two technical replicates. (https://trace.ncbi.nlm.nih.gov/Traces/sra/?study=SRP047233)


### Download data & summarize basic info

First, we download the data using the recount R package as shown in its vignette. Note that we use the read_counts() function instead of scale_counts() to convert the provided base pair counts to read counts, so that we get the raw counts without normalization.

```{r, echo=FALSE, results='hide'}
rm(list=ls())
output_dir <- "~/Google Drive/ComBat_seq/real_data_example/RNAseq/CHD8"
sapply(c("recount", "DESeq2", "edgeR", "dendextend", "ggplot2", "reshape2", "gridExtra", "scales", 
         "ggdendro", "MASS"), require, character.only=TRUE)


####  Load data
# abstract_search('batch')$project
study_SRP <- "SRP047233"
download_study(study_SRP)
load(file.path(study_SRP, 'rse_gene.Rdata'))
meta_info <- as.data.frame(colData(rse_gene))

## Obtain (unnormalized) read counts from provided base pair coverage counts
rse_gene <- read_counts(rse_gene, round=TRUE) #scale_counts(rse_gene)  

## Batch indicator
batch <- sapply(meta_info$characteristics, function(s){s[grep("batch",s)]})
batch <- as.factor(batch)
batch <- sapply(batch, function(b){return(which(levels(batch)==b))})

## Condition indicator
group <- rep(NA, nrow(meta_info))
group[grep("CHD8", meta_info$title)] <- "CHD8"
group[grep("GFP", meta_info$title)] <- "GFP"
group[grep("LacZ", meta_info$title)] <- "LacZ"
group_num <- rep(0, nrow(meta_info)); group_num[group=="CHD8"] <- 1
#group <- sapply(meta_info$characteristics, function(s){s[grep("shRNA target gene",s)]})
  
## Add batch and condition in meta info
colData(rse_gene)$batch <- as.factor(batch)
colData(rse_gene)$condition <- as.factor(group)
colData(rse_gene)$condition_bi <- as.factor(group_num)

##  Save data in desired format
save(rse_gene, file=file.path(output_dir, 'rse_gene.Rdata'))
unlink(file.path(study_SRP), recursive=TRUE)
```

After downloading the data, we calculate a few basic statistics of the dataset.

```{r, echo=FALSE}
cat("######  Samples  #######\n")
cat("- Total number of samples:\n")
print(ncol(rse_gene))

cat("\n- Number of samples in condition groups:\n")
print(table(group))

cat("\n- Number of samples in batches:\n")
print(table(batch))
cat("In batch 1:")
print(table(group[batch==1]))
cat("In batch 2:")
print(table(group[batch==2]))


cat("\n\n######  Genes  #######\n")
cat("- Total number of genes:\n")
print(nrow(rse_gene))

cat("\n- Number of genes with 0 counts:\n")
gene_row_with_zeros <- apply(assay(rse_gene, "counts"), 1, function(x){any(x==0)})
cat(c(sum(gene_row_with_zeros), percent(sum(gene_row_with_zeros)/nrow(rse_gene))))

cat("\n\n- Number of genes with maximum 10 counts:\n")
gene_row_low <- apply(assay(rse_gene, "counts"), 1, function(x){all(x<=10)})
cat(c(sum(gene_row_low), percent(sum(gene_row_low)/nrow(rse_gene))))

cat("\n\n- Number of genes with ONLY 0s:\n")
gene_all_zeros <- apply(assay(rse_gene, "counts"), 1, function(x){all(x==0)})
cat(c(sum(gene_all_zeros), percent(sum(gene_all_zeros)/nrow(rse_gene))))


cat("\n\n\n######  Counts  #######\n")
cat("- Range of count in whole dataset:\n")
print(round(range(assay(rse_gene, "counts")), 3))

cat("\n- Average count in whole dataset:\n")
print(paste("Mean:", round(mean(assay(rse_gene, "counts")), 3)))
print(paste("Median:", round(median(assay(rse_gene, "counts")), 3)))

rm(gene_row_with_zeros, gene_row_low, gene_all_zeros)
```

For the following analysis, **we remove genes with only zero values across all samples**. 

```{r}
## Remove genes with all 0 counts
rse_gene <- rse_gene[apply(assay(rse_gene, "counts"), 1, function(x){!all(x==0)}), ]
print(dim(rse_gene))
```

The figure below shows distribution of percentages of zero counts for the remaining genes (each data point represents a gene, i.e., how many zeros are there in each gene).

```{r, echo=FALSE}
n_zeros_in_genes <- apply(assay(rse_gene, "counts"), 1, function(x){length(which(x==0))})
percent_zeros_in_genes <- n_zeros_in_genes / ncol(rse_gene)
percent_zeros_df <- data.frame(genes=rownames(rse_gene), value=percent_zeros_in_genes)

binned_cts <- hist(percent_zeros_in_genes, breaks=10, plot=FALSE)$counts 
binned_proportions <- binned_cts / sum(binned_cts)
names(binned_proportions) <- paste0("<", percent(seq(from=0.1, to=1, by=0.1)))  
cat("######  Proportion of genes with X% zeros across samples  #######\n")
print(round(binned_proportions,3))

ggplot(percent_zeros_df, aes(0, value)) + 
      geom_violin() +
      geom_boxplot(aes(0.7, value), width=0.15) +
      coord_flip() +
      annotate(geom="text", label=percent(median(percent_zeros_df$value)), x=0.85, y=median(percent_zeros_df$value)) +
      labs(y="% Zeros", title="Proportion of zeros across samples for the remaining genes") +
      theme(axis.title.y=element_blank())#, axis.text.y=element_blank())
```

```{r, echo=FALSE}
rm(n_zeros_in_genes, percent_zeros_in_genes, percent_zeros_df)
```



## Existence of batch effect {.tabset}

We first visualize the data using PCA and hierarchical clustering, to see if there is any batch effect in the dataset. Based on these plots, I believe there exists a certain level of batch effect in the data, as samples cluster more by batch than by biological condition.

### PCA

```{r, echo=FALSE, fig.height=2, fig.width=5}
pca_obj <- plotPCA(DESeqTransform(rse_gene), intgroup=c("batch", "condition_bi")) 
colnames(pca_obj$data)[5] <- "cond"
p_batch <- ggplot(pca_obj$data, aes(x=PC1, y=PC2, color=batch)) +
  geom_point() + 
  scale_color_manual(values=c('#E69F00', '#56B4E9'))+
  labs(x=sprintf("PC1: %s Variance", percent(pca_obj$plot_env$percentVar[1])),
       y=sprintf("PC2: %s Variance", percent(pca_obj$plot_env$percentVar[2])),
       title="PCA: samples colored by Batch")
p_cond <- ggplot(pca_obj$data, aes(x=PC1, y=PC2, color=cond)) +
  geom_point() + 
  labs(x=sprintf("PC1: %s Variance", percent(pca_obj$plot_env$percentVar[1])),
       y=sprintf("PC2: %s Variance", percent(pca_obj$plot_env$percentVar[2])),
       title="PCA: samples colored by Condition")
grid.arrange(p_batch, p_cond, ncol=2)
```


### Dendrograms

```{r, echo=FALSE, fig.height=3, fig.width=5}
counts_norm <- scale(t(assay(rse_gene,"counts")), center=TRUE, scale=TRUE)
hc <- hclust(dist(counts_norm))
dend <- as.dendrogram(hc)
ddata <- dendro_data(dend, type="rectangle")

meta_info <- data.frame(colData(rse_gene)[, c("batch", "condition_bi")], sample=colnames(rse_gene))
colnames(meta_info)[2] <- "cond"
tmp <- merge(x=ddata$labels, y=meta_info, by.x="label", by.y="sample")

pd_batch <- ggplot(segment(ddata)) + 
  geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) + 
  coord_flip() + scale_y_reverse() +
  scale_color_manual(values=c('#E69F00', '#56B4E9')) +
  geom_text(data=tmp, aes(label=sapply(as.character(tmp$label), function(s){substr(s,nchar(s)-2,nchar(s))}), 
                          x=x, y=-10, colour=batch)) +
  labs(x="", y="", title="Clustering: samples colored by Batch")
pd_cond <- ggplot(segment(ddata)) + 
  geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) + 
  coord_flip() + scale_y_reverse() +
  geom_text(data=tmp, aes(label=sapply(as.character(tmp$label), function(s){substr(s,nchar(s)-2,nchar(s))}), 
                          x=x, y=-10, colour=cond)) +
  labs(x="", y="", title="Clustering: samples colored by Condition")
grid.arrange(pd_batch, pd_cond, ncol=2)

rm(counts_norm, ddata, dend, hc, p_batch, p_cond, pca_obj, pd_batch, pd_cond, tmp)
```



## Library size

Next, we take a look at the observed library sizes of samples, and to see if there is a difference in library size across batches.

```{r, echo=FALSE}
###  Distribution of library size
lib_sizes <- colSums(assay(rse_gene, "counts"))
cat("Range of observed library sizes across samples:\n")
print(scientific(range(lib_sizes)))
```

```{r, echo=FALSE, fig.height=2, fig.width=4}
lib_sizes_df <- data.frame(lib_sizes=lib_sizes, batch=as.factor(batch))

# overall sample library sizes
plib1 <- ggplot(lib_sizes_df, aes(x=lib_sizes)) + 
  geom_histogram(bins=round(ncol(rse_gene)/5)) +
  geom_vline(aes(xintercept=mean(lib_sizes)), color="red", linetype="dashed", size=1) +
  annotate(geom="text", x=mean(lib_sizes), y=max(hist(lib_sizes, plot=FALSE)$counts)+1, 
           label=scientific(mean(lib_sizes)), color="red") +
  labs(x="Library sizes in samples", y="Number of samples", 
       title="Distribution of observed library sizes") 

# boxplot comparing distribution of library size across batches
plib2 <- ggplot(lib_sizes_df, aes(x=batch, y=lib_sizes, fill=batch)) + 
  geom_boxplot() +
  labs(x="", y="Library sizes", title="Compare library sizes across batch") 

grid.arrange(plib1, plib2, ncol=2)

rm(plib1, plib2)
```



## Gene expression distribution

Our next step is to interrogate the gene expression distributions. 

We first simply plot the counts, CPM, and log2CPM of 20 randomly chosen genes in the dataset. These figures are stored under directory specified by output_dir.  

```{r, echo=FALSE, results='hide', eval=FALSE}
if(!dir.exists(file.path(output_dir, "randGplots"))){dir.create(file.path(output_dir, "randGplots"))}
set.seed(123)
N_sel <- 20
chosen_id <- sample(1:nrow(rse_gene), N_sel, replace=FALSE)

cts_subset <- assay(rse_gene, "counts")[chosen_id, ]
cpm_subset <- cpm(assay(rse_gene, "counts"), log=FALSE)[chosen_id, ]
logCPM_subset <- cpm(assay(rse_gene, "counts"), log=TRUE)[chosen_id, ]
data_lst <- list(Counts=cts_subset, CPM=cpm_subset, log2CPM=logCPM_subset)

void <- mapply(function(dat, dat_name, meta_info){
  for(i in 1:nrow(dat)){
    # prepare data frame
    curr_df <- data.frame(samples=colnames(dat), value=dat[i, ])
    curr_df <- merge(x=curr_df, y=meta_info, by.x="samples", by.y="sample")
    
    # scatter plot for i-th gene
    p_scatter <- ggplot(curr_df, aes(x=samples, y=value, color=batch, shape=cond)) +
      geom_point() +
      labs(x="Samples", y=dat_name, title=rownames(dat)[i]) +
      theme(axis.text.x=element_blank())
    
    # violin plot for i-th gene
    p_violin <- ggplot(curr_df, aes(0, value)) + 
      geom_violin() +
      geom_boxplot(width=0.2) +
      coord_flip() +
      geom_text(aes(label=as.integer(median(curr_df$value)), x=0.12, y=median(curr_df$value))) +
      labs(y=dat_name, title=sprintf("All samples, %s", rownames(dat)[i])) +
      theme(axis.title.y=element_blank())
    
    # violin plot group by batch
    medians_batch <- aggregate(value ~ batch, data=curr_df, FUN=median)
    p_violin_batch <- ggplot(curr_df, aes(x=batch, y=value, color=batch)) + 
      geom_violin() +
      geom_boxplot(width=0.2) +
      coord_flip() +
      scale_color_manual(values=c('#E69F00', '#56B4E9')) +
      geom_text(data=medians_batch, 
                aes(label=round(medians_batch$value,2), x=as.numeric(as.character(medians_batch$batch))+0.12,
                    y=as.numeric(as.character(medians_batch$value)))) +
      labs(y=dat_name, title=sprintf("In batches, %s", rownames(dat)[i])) +
      theme(axis.title.y=element_blank())
    
    # violin plot group by condition
    medians_cond <- aggregate(value ~ cond, data=curr_df, FUN=median)
    p_violin_cond <- ggplot(curr_df, aes(x=cond, y=value, color=cond)) + 
      geom_violin() +
      geom_boxplot(width=0.2) +
      coord_flip() +
      geom_text(data=medians_cond,
                aes(label=round(medians_cond$value,2), x=as.numeric(as.character(medians_cond$cond))+1.12, 
                    y=as.numeric(as.character(medians_cond$value)))) +
      labs(y=dat_name, title=sprintf("In condition groups, %s", rownames(dat)[i])) +
      theme(axis.title.y=element_blank())
    
    # output plot
    png(sprintf("%s/%s_gene%s.png", file.path(output_dir, "randGplots"), dat_name, i),
        width=10, height=8, units="in", res=300)
    grid.arrange(p_scatter, p_violin, p_violin_batch, p_violin_cond, nrow=2, ncol=2)
    dev.off()
  }
}, dat=data_lst, dat_name=names(data_lst), meta_info=list(meta_info,meta_info,meta_info))

rm(cts_subset, cpm_subset, logCPM_subset, lib_sizes, lib_sizes_df, chosen_id, data_lst, void, N_sel)
```


### Fold changes in mean {.tabset}

We then use edgeR to perform differential expression analysis, and calculate (log-) fold changes of all genes between condition groups and batches.

#### Change WRT condition

To rule out the impact of batch effect, we limit our DE analysis with regard to biological condition in one of the batches. Here we specify the batch to be **Batch 1** due to a larger batch size.

```{r, results="hide"}
####  Differential genes relative to biological condition 
####  (within batch 1 / batch specified by 'test_batch')
test_batch <- 1
counts_batch <- assay(rse_gene,"counts")[, batch==test_batch]
cond_batch <- group_num[batch==test_batch]

y <- DGEList(counts=counts_batch, group=as.factor(cond_batch))
y <- calcNormFactors(y, method="TMM")
design <- model.matrix(~as.factor(cond_batch))
y <- estimateDisp(y, design)
fit <- glmQLFit(y, design)
qlf <- glmQLFTest(fit, coef=2)
de_res <- topTags(qlf, n=nrow(rse_gene))
 
up_genes <- rownames(de_res)[de_res$table$logFC >= 0]  # all up-regulated genes (descending order in terms of p value)
head_up_genes <- head(up_genes, n=50)  # top-50 significant up-regulated genes
tail_up_genes <- tail(up_genes, n=50)  # 50 least significant up-regulated genes

cond_up_inds <- up_genes

down_genes <- rownames(de_res)[de_res$table$logFC < 0]  # all down-regulated genes
head_down_genes <- head(down_genes, n=50)  # top-50 significant down-regulated genes
tail_down_genes <- tail(down_genes, n=50)  # 50 least significant down-regulated genes

cond_down_inds <- down_genes
```

```{r, echo=FALSE, message=FALSE}
# changes in terms of mean
cat("######  Changes in terms of average gene counts  ######\n")
mean_cts_mat <- matrix(NA, nrow=2, ncol=3, 
                       dimnames=list(c("Controls", "Cases"), c("top50 up", "top50 down", "100 least DE")))
mean_cts_mat["Controls", "top50 up"] <- mean(counts_batch[head_up_genes, cond_batch==0])
mean_cts_mat["Cases", "top50 up"] <- mean(counts_batch[head_up_genes, cond_batch==1])
mean_cts_mat["Controls", "top50 down"] <- mean(counts_batch[head_down_genes, cond_batch==0])
mean_cts_mat["Cases", "top50 down"] <- mean(counts_batch[head_down_genes, cond_batch==1])
mean_cts_mat["Controls", "100 least DE"] <- mean(counts_batch[c(tail_up_genes, tail_down_genes), cond_batch==0])
mean_cts_mat["Cases", "100 least DE"] <- mean(counts_batch[c(tail_up_genes, tail_down_genes), cond_batch==1])
print(round(mean_cts_mat,1))

# changes in terms of (log) fold change
cat("\n######  Range of fold change across biological conditions  ######\n")
FC_mat <- matrix(NA, nrow=4, ncol=3, 
                 dimnames=list(c("min FC", "median FC", "mean FC", "max FC"), 
                               c("top50 up", "top50 down", "100 least DE")))
FC_mat[, "top50 up"] <- sapply(c(min, median, mean, max), function(ff){ff(exp(de_res$table[head_up_genes, "logFC"]))})
FC_mat[, "top50 down"] <- sapply(c(min, median, mean, max), function(ff){ff(exp(de_res$table[head_down_genes, "logFC"]))})
FC_mat[, "100 least DE"] <- sapply(c(min, median, mean, max), function(ff){
  ff(exp(de_res$table[c(tail_up_genes, tail_down_genes), "logFC"]))
})
print(round(FC_mat,3))

cat("\n######  Range of Log(fold change) across biological conditions  ######\n")
logFC_mat <- log(FC_mat)
rownames(logFC_mat) <- c("min logFC", "median logFC", "mean logFC", "max logFC")
print(round(logFC_mat,3))


# visualize change in terms of (log) fold change
logFC_df <- data.frame(top50up=de_res$table[head_up_genes, "logFC"], top50down=de_res$table[head_down_genes, "logFC"])
FC_df <- exp(logFC_df)
p_logFC <- ggplot(melt(logFC_df), aes(x=variable, y=value)) +
  geom_boxplot() +
  labs(y="logFC") +
  theme(axis.title.x=element_blank())
p_FC <- ggplot(melt(FC_df), aes(x=variable, y=value)) +
  geom_boxplot() +
  labs(y="FC") +
  theme(axis.title.x=element_blank())
grid.arrange(p_logFC, p_FC, ncol=2)
```

```{r, echo=FALSE, results='hide'}
rm(cond_batch, counts_batch, up_genes, head_up_genes, tail_up_genes, 
   down_genes, head_down_genes, tail_down_genes, y, design, fit, qlf, de_res, 
   mean_cts_mat, FC_mat, p_FC, p_logFC, FC_df, logFC_df, logFC_mat)
```

**Conclusions:**

+ Biological fold change comparing average counts **in top DE genes** is about 2-2.2. 
+ Gene-wise fold change of **top DE genes** has a wide range (median 3, mean 7).


#### Change WRT batch

We are also interested to see how the average (mean) gene counts change across batches (i.e. **degree of mean batch effect**). 

To explore this mean batch effect, we **first perform DE with regard to the batch variable**. To rule out the impact of biological condition, we perform this analysis within **control** samples only. Note that this DE is not true DE - it's testing if there is a significant mean difference between two batches. Some genes will not be different in mean, while some will. Which means that batch doesn't affect all genes in the same way.

```{r, results="hide"}
####  Differential genes relative to batch 
####  (within condition 0 / condition specified by 'test_cond')
test_cond <- 0
counts_cond <- assay(rse_gene,"counts")[, group_num==test_cond]
batch_cond <- batch[group_num==test_cond]

y <- DGEList(counts=counts_cond, group=as.factor(batch_cond))
y <- calcNormFactors(y, method="TMM")
design <- model.matrix(~as.factor(batch_cond))
y <- estimateDisp(y, design)
fit <- glmQLFit(y, design)
qlf <- glmQLFTest(fit, coef=2)
de_res <- topTags(qlf, n=nrow(rse_gene))

up_genes <- rownames(de_res)[de_res$table$logFC >= 0]  # all up-regulated genes
head_up_genes <- head(up_genes, n=50)  # top-50 up-regulated genes
tail_up_genes <- tail(up_genes, n=50)  # 50 least up-regulated genes

batch_up_inds <- up_genes

down_genes <- rownames(de_res)[de_res$table$logFC < 0]  # all down-regulated genes
head_down_genes <- head(down_genes, n=50)  # top-50 down-regulated genes
tail_down_genes <- tail(down_genes, n=50)  # 50 least down-regulated genes

batch_down_inds <- down_genes
```

```{r, echo=FALSE}
# changes in terms of mean
cat("######  Batch differences in terms of mean gene counts  ######\n")
mean_cts_mat <- matrix(NA, nrow=2, ncol=3, 
                       dimnames=list(c("Batch1", "Batch2"), c("top50 up", "top50 down", "100 least changed")))
mean_cts_mat["Batch1", "top50 up"] <- mean(counts_cond[head_up_genes, batch_cond==1])
mean_cts_mat["Batch2", "top50 up"] <- mean(counts_cond[head_up_genes, batch_cond==2])
mean_cts_mat["Batch1", "top50 down"] <- mean(counts_cond[head_down_genes, batch_cond==1])
mean_cts_mat["Batch2", "top50 down"] <- mean(counts_cond[head_down_genes, batch_cond==2])
mean_cts_mat["Batch1", "100 least changed"] <- mean(counts_cond[c(tail_up_genes, tail_down_genes), batch_cond==1])
mean_cts_mat["Batch2", "100 least changed"] <- mean(counts_cond[c(tail_up_genes, tail_down_genes), batch_cond==2])
print(round(mean_cts_mat,2))

# changes in terms of fold change
cat("\n######  Range of fold change between batches  ######\n")
cat("- All genes - FC:\n")
cat(round(range(exp(de_res$table$logFC)), 3)) 

cat("\n\n- All genes - log(FC):\n")
cat(round(range(de_res$table$logFC), 3)) 

cat("\n\n- Top genes - FC:\n")
FC_mat <- matrix(NA, nrow=4, ncol=3, 
                 dimnames=list(c("min FC", "median FC", "mean FC", "max FC"), 
                               c("top50 up", "top50 down", "100 least DE")))
FC_mat[, "top50 up"] <- sapply(c(min, median, mean, max), function(ff){ff(exp(de_res$table[head_up_genes, "logFC"]))})
FC_mat[, "top50 down"] <- sapply(c(min, median, mean, max), function(ff){ff(exp(de_res$table[head_down_genes, "logFC"]))})
FC_mat[, "100 least DE"] <- sapply(c(min, median, mean, max), function(ff){
  ff(exp(de_res$table[c(tail_up_genes, tail_down_genes), "logFC"]))
})
print(round(FC_mat,3))

cat("\n- Top genes - log(FC):\n")
logFC_mat <- log(FC_mat)
rownames(logFC_mat) <- c("min logFC", "median logFC", "mean logFC", "max logFC")
print(round(logFC_mat,3))

```

```{r, echo=FALSE, results='hide'}
rm(batch_cond, counts_cond, up_genes, head_up_genes, tail_up_genes, 
   down_genes, head_down_genes, tail_down_genes, y, design, fit, qlf, de_res, 
   mean_cts_mat, FC_mat, logFC_mat)
```

**Conclusions:**

+ Mean batch effect fold change comparing average counts **in top genes** ranges from 1.6-4. 
+ Gene-wise mean batch effect fold change **in top genes** has a wide range (mean 4.8, median 24).


### Batch mean

**Median (of all genes)** gene-wise mean across all batches: 

```{r, echo=FALSE}
mean_tb <- matrix(NA, nrow=2, ncol=nlevels(as.factor(batch)), 
                 dimnames=list(c("Controls", "Cases"), paste0("Batch", levels(as.factor(batch)))))
mean_tb["Controls", "Batch1"] <- median(rowMeans(assay(rse_gene,"counts")[, batch==1&group_num==0]))
mean_tb["Controls", "Batch2"] <- median(rowMeans(assay(rse_gene,"counts")[, batch==2&group_num==0]))
mean_tb["Cases", "Batch1"] <- median(rowMeans(assay(rse_gene,"counts")[, batch==1&group_num==1]))
mean_tb["Cases", "Batch2"] <- median(rowMeans(assay(rse_gene,"counts")[, batch==2&group_num==1]))
print(round(mean_tb, 2))
```

Scaled by that of batch 1:

```{r, echo=FALSE}
mean_tb_scaled <- apply(mean_tb, 2, function(x){x/mean_tb[,"Batch1"]})
print(round(mean_tb_scaled, 2))
```


### Batch dispersion

Aside from average gene counts, we are interested in comparing dispersions in the two batches. **Difference in the dispersions across batches suggests variance batch effect not specified by Poisson model**. We visualize the gene-wise dispersion estimates from edgeR:

```{r, echo=FALSE}
####  Dispersion differences across batch 1 and 2
y_batch1 <- DGEList(counts=assay(rse_gene,"counts")[, batch==1], group=as.factor(group_num[batch==1]))
y_batch1 <- calcNormFactors(y_batch1, method="TMM")
design_batch1 <- model.matrix(~as.factor(group_num[batch==1]))
y_batch1 <- estimateDisp(y_batch1, design_batch1)

y_batch2 <- DGEList(counts=assay(rse_gene,"counts")[, batch==2], group=as.factor(group_num[batch==2]))
y_batch2 <- calcNormFactors(y_batch2, method="TMM")
design_batch2 <- model.matrix(~as.factor(group_num[batch==2]))
y_batch2 <- estimateDisp(y_batch2, design_batch2)

disp_df <- data.frame(Batch1=y_batch1$tagwise.dispersion, Batch2=y_batch2$tagwise.dispersion)

cat("####  Statistics about dispersion estimates from the two batches  ####\n")
disp_stats <- lapply(c(min, median, mean, max), function(ff){apply(disp_df, 2, ff)})
disp_stats <- do.call(rbind, disp_stats)
rownames(disp_stats) <- c("min disp.", "median disp.", "mean disp.", "max disp.")
print(round(disp_stats, 4))
```

```{r, echo=FALSE, message=FALSE}
disp_df_mlt <- melt(disp_df)
ggplot(disp_df_mlt, aes(x=variable, y=value)) +
  geom_violin() +
  labs(x="Batch", y="Estimated gene-wise dispersion", 
       title="Comparison of estimated dispersion across batches") +
  stat_summary(fun.y=mean, colour="darkred", geom="point", shape=18, size=3) +
  scale_y_continuous(limits=c(0, 1))
```

**Conclusions:**

+ Mean dispersion in Batch 1 is about 3 times of those in Batch 2. 
+ We see huge gene-wise dispersions, possibly caused by 0 counts.


### Batch variance

**Median (of all genes)** gene-wise variance: 

```{r, echo=FALSE}
var_tb <- matrix(NA, nrow=2, ncol=nlevels(as.factor(batch)), 
                 dimnames=list(c("Controls", "Cases"), paste0("Batch", levels(as.factor(batch)))))
var_tb["Controls", "Batch1"] <- median(rowVars(assay(rse_gene,"counts")[, batch==1&group_num==0]))
var_tb["Controls", "Batch2"] <- median(rowVars(assay(rse_gene,"counts")[, batch==2&group_num==0]))
var_tb["Cases", "Batch1"] <- median(rowVars(assay(rse_gene,"counts")[, batch==1&group_num==1]))
var_tb["Cases", "Batch2"] <- median(rowVars(assay(rse_gene,"counts")[, batch==2&group_num==1]))
print(round(var_tb, 2))
```

Scaled by that of batch 1:

```{r, echo=FALSE}
var_tb_scaled <- apply(var_tb, 2, function(x){x/var_tb[,"Batch1"]})
print(round(var_tb_scaled, 2))
```


## Impact of 0 counts on gene distributions

We have seen above that over half of genes in the dataset contain some portions of zeros. Having 0 counts can have a good impact on mean and dispersion estimation. We evaluate such impact in this section, and see how NB distribution fits to non-zero portion of genes. We first take the non-zero portion of the genes.

### Fold change in mean in non-zero portion {.tabset}

```{r, echo=FALSE}
cts <- assay(rse_gene, "counts")

# take the non-zero portion in each gene
batch_sep <- group_sep <- nonzero_cts <- list()
for(i in 1:nrow(cts)){
  nonzero_ind <- which(cts[i, ]!=0)
  batch_sep[[i]] <- batch[nonzero_ind]
  group_sep[[i]] <- group_num[nonzero_ind]
  nonzero_cts[[i]] <- cts[i, nonzero_ind]
}
# sanity check
if(!identical(sapply(nonzero_cts, length), as.integer(rowSums(cts!=0)))){stop("Error in taking non-zero portions!")}

names(nonzero_cts) <- rownames(cts); names(batch_sep) <- rownames(cts); names(group_sep) <- rownames(cts)
```

####  Change WRT condition in batch 1

Within **batch 1**, we compare mean (here refers to non-zero mean) across biological condition groups. Specifically, **we saved the previous DE analysis results using edgeR, on counts containing zeros**. We call all genes with $\log(FC) >= 0$ as "up" genes, and $\log(FC) < 0$ as "down" genes. The top 50 "up" and "down" genes are still determined by the previous DE containing zeros. 

```{r, echo=FALSE}
# take batch 1
group_sep_batch1 <- nonzero_cts_batch1 <- list()
for(i in 1:length(nonzero_cts)){
  group_sep_batch1[[i]] <- group_sep[[i]][batch_sep[[i]]==1]
  nonzero_cts_batch1[[i]] <- nonzero_cts[[i]][batch_sep[[i]]==1]
}
names(nonzero_cts_batch1) <- names(group_sep_batch1) <- rownames(cts)

# split into controls & cases
nonzero_cts_b1_ctrls <- nonzero_cts_b1_cases <- list()
for(j in 1:length(nonzero_cts_batch1)){
  nonzero_cts_b1_ctrls[[j]] <- nonzero_cts_batch1[[j]][group_sep_batch1[[j]]==0]
  nonzero_cts_b1_cases[[j]] <- nonzero_cts_batch1[[j]][group_sep_batch1[[j]]==1]
}#identical(sapply(nonzero_cts_b1_ctrls, length) + sapply(nonzero_cts_b1_cases, length), sapply(nonzero_cts_batch1,length))
names(nonzero_cts_b1_ctrls) <- names(nonzero_cts_b1_cases) <- rownames(cts)

# top 50 up and down indices
top_up_ind <- head(cond_up_inds, 50)
top_down_ind <- head(cond_down_inds, 50)
least_de_ind <- c(tail(cond_up_inds, 50), tail(cond_down_inds, 50))

# calculate mean in top up, down and least DE
cat("######  Changes in MEAN non-zero gene counts  ######\n")
mean_nonzerocts_mat <- matrix(NA, nrow=2, ncol=3, 
                              dimnames=list(c("Controls", "Cases"), c("top50 up", "top50 down", "100 least DE")))
mean_nonzerocts_mat["Controls", "top50 up"] <- mean(do.call(c, nonzero_cts_b1_ctrls[top_up_ind]))
mean_nonzerocts_mat["Cases", "top50 up"] <- mean(do.call(c, nonzero_cts_b1_cases[top_up_ind]))
mean_nonzerocts_mat["Controls", "top50 down"] <- mean(do.call(c, nonzero_cts_b1_ctrls[top_down_ind]))
mean_nonzerocts_mat["Cases", "top50 down"] <- mean(do.call(c, nonzero_cts_b1_cases[top_down_ind]))
mean_nonzerocts_mat["Controls", "100 least DE"] <- mean(do.call(c, nonzero_cts_b1_ctrls[least_de_ind]))
mean_nonzerocts_mat["Cases", "100 least DE"] <- mean(do.call(c, nonzero_cts_b1_cases[least_de_ind]))
print(round(mean_nonzerocts_mat,1))
```

```{r,echo=FALSE}
cat("######  Changes in MEDIAN non-zero gene counts  ######\n")
median_nonzerocts_mat <- matrix(NA, nrow=2, ncol=3, 
                              dimnames=list(c("Controls", "Cases"), c("top50 up", "top50 down", "100 least DE")))
median_nonzerocts_mat["Controls", "top50 up"] <- median(do.call(c, nonzero_cts_b1_ctrls[top_up_ind]))
median_nonzerocts_mat["Cases", "top50 up"] <- median(do.call(c, nonzero_cts_b1_cases[top_up_ind]))
median_nonzerocts_mat["Controls", "top50 down"] <- median(do.call(c, nonzero_cts_b1_ctrls[top_down_ind]))
median_nonzerocts_mat["Cases", "top50 down"] <- median(do.call(c, nonzero_cts_b1_cases[top_down_ind]))
median_nonzerocts_mat["Controls", "100 least DE"] <- median(do.call(c, nonzero_cts_b1_ctrls[least_de_ind]))
median_nonzerocts_mat["Cases", "100 least DE"] <- median(do.call(c, nonzero_cts_b1_cases[least_de_ind]))
print(round(median_nonzerocts_mat,1))
```

**Conclusions: ** 

+ Biological fold change (in non-zero portion) comparing average counts **in top genes** is about 1.9-2.2 (mean), 1.1-2.5 (median).**
+ O counts did not strongly affect biological signal in terms of average counts **in top genes**.


####  Change WRT batch in control samples

Similarly, we compare non-zero mean **in top genes** across batches within control samples. Here "top genes" refer to top gene lists from previous DE within control samples comparing batches. 

```{r, echo=FALSE}
# take controls
batch_sep_cond0 <- nonzero_cts_cond0 <- list()
for(i in 1:length(nonzero_cts)){
  batch_sep_cond0[[i]] <- batch_sep[[i]][group_sep[[i]]==0]
  nonzero_cts_cond0[[i]] <- nonzero_cts[[i]][group_sep[[i]]==0]
}
names(batch_sep_cond0) <- names(nonzero_cts_cond0) <- rownames(cts)

# split into batch 1 & 2
nonzero_cts_cond0_batch1 <- nonzero_cts_cond0_batch2 <- list()
for(j in 1:length(nonzero_cts)){
  nonzero_cts_cond0_batch1[[j]] <- nonzero_cts_cond0[[j]][batch_sep_cond0[[j]]==1]
  nonzero_cts_cond0_batch2[[j]] <- nonzero_cts_cond0[[j]][batch_sep_cond0[[j]]==2]
}
names(nonzero_cts_cond0_batch1) <- names(nonzero_cts_cond0_batch2) <- rownames(cts)

# top 50 up and down indices
top_up_ind <- head(batch_up_inds, 50)
top_down_ind <- head(batch_down_inds, 50)
least_de_ind <- c(tail(batch_up_inds, 50), tail(batch_down_inds, 50))

# calculate mean in top up, down and least DE
cat("######  Changes in MEAN non-zero gene counts  ######\n")
mean_nonzerocts_mat <- matrix(NA, nrow=2, ncol=3, 
                              dimnames=list(c("Batch 1", "Batch 2"), c("top50 up", "top50 down", "100 least DE")))
mean_nonzerocts_mat["Batch 1", "top50 up"] <- mean(do.call(c, nonzero_cts_cond0_batch1[top_up_ind]))
mean_nonzerocts_mat["Batch 2", "top50 up"] <- mean(do.call(c, nonzero_cts_cond0_batch2[top_up_ind]))
mean_nonzerocts_mat["Batch 1", "top50 down"] <- mean(do.call(c, nonzero_cts_cond0_batch1[top_down_ind]))
mean_nonzerocts_mat["Batch 2", "top50 down"] <- mean(do.call(c, nonzero_cts_cond0_batch2[top_down_ind]))
mean_nonzerocts_mat["Batch 1", "100 least DE"] <- mean(do.call(c, nonzero_cts_cond0_batch1[least_de_ind]))
mean_nonzerocts_mat["Batch 2", "100 least DE"] <- mean(do.call(c, nonzero_cts_cond0_batch2[least_de_ind]))
print(round(mean_nonzerocts_mat,1))
```

```{r, echo=FALSE}
# calculate median in top up, down and least DE
cat("######  Changes in MEDIAN non-zero gene counts  ######\n")
median_nonzerocts_mat <- matrix(NA, nrow=2, ncol=3, 
                                dimnames=list(c("Batch 1", "Batch 2"), c("top50 up", "top50 down", "100 least DE")))
median_nonzerocts_mat["Batch 1", "top50 up"] <- median(do.call(c, nonzero_cts_cond0_batch1[top_up_ind]))
median_nonzerocts_mat["Batch 2", "top50 up"] <- median(do.call(c, nonzero_cts_cond0_batch2[top_up_ind]))
median_nonzerocts_mat["Batch 1", "top50 down"] <- median(do.call(c, nonzero_cts_cond0_batch1[top_down_ind]))
median_nonzerocts_mat["Batch 2", "top50 down"] <- median(do.call(c, nonzero_cts_cond0_batch2[top_down_ind]))
median_nonzerocts_mat["Batch 1", "100 least DE"] <- median(do.call(c, nonzero_cts_cond0_batch1[least_de_ind]))
median_nonzerocts_mat["Batch 2", "100 least DE"] <- median(do.call(c, nonzero_cts_cond0_batch2[least_de_ind]))
print(round(median_nonzerocts_mat,1))
```

**Conclusions:** 

+ Mean batch effect fold change (non-zero portion) comparing average counts **in top genes** ranges from 1.5-3.9 (mean), 1.33-5.9 (median). 
+ O counts did not strongly affect mean batch effect in terms of average counts **in top genes**.


### Batch mean with 0 counts removed 

**Median (of all genes)** gene-wise mean after removing zeros: 

```{r, echo=FALSE}
mean_tb_rmzero <- matrix(NA, nrow=2, ncol=nlevels(as.factor(batch)), 
                        dimnames=list(c("Controls", "Cases"), paste0("Batch", levels(as.factor(batch)))))
cts_rmzero <- assay(rse_gene,"counts"); cts_rmzero[cts_rmzero==0] <- NA
mean_tb_rmzero["Controls", "Batch1"] <- median(rowMeans(cts_rmzero[, batch==1&group_num==0], na.rm=TRUE), na.rm=TRUE)
mean_tb_rmzero["Controls", "Batch2"] <- median(rowMeans(cts_rmzero[, batch==2&group_num==0], na.rm=TRUE), na.rm=TRUE)
mean_tb_rmzero["Cases", "Batch1"] <- median(rowMeans(cts_rmzero[, batch==1&group_num==1], na.rm=TRUE), na.rm=TRUE)
mean_tb_rmzero["Cases", "Batch2"] <- median(rowMeans(cts_rmzero[, batch==2&group_num==1], na.rm=TRUE), na.rm=TRUE)
print(round(mean_tb_rmzero, 2))
```

Scaled by that of batch 1:

```{r, echo=FALSE}
mean_tb_rmzero_scaled <- apply(mean_tb_rmzero, 2, function(x){x/mean_tb_rmzero[,"Batch1"]})
print(round(mean_tb_rmzero_scaled, 2))
```


### Batch dispersion with 0 counts removed 

Dispersion estimates are more likely impacted by 0 counts. We re-estimate the dispersions in each batch, using non-zero portion of each gene. Then we compare the dispersion estimates across batches.

```{r, echo=FALSE}
load(file.path(output_dir, "disps_nonzero.RData"))
disp_nonzero_lst <- list(Batch1=disp_nonzero_batch1, Batch2=disp_nonzero_batch2)

cat("####  Statistics about dispersion estimates (from NON-ZERO portions) from the two batches  ####\n")
disp_stats <- lapply(c(min, median, mean, max), function(ff){sapply(disp_nonzero_lst, ff)})
disp_stats <- do.call(rbind, disp_stats)
rownames(disp_stats) <- c("min disp.", "median disp.", "mean disp.", "max disp.")
print(round(disp_stats, 4))
```

```{r, echo=FALSE, message=FALSE}
disp_nonzero_df <- data.frame(Batch=c(rep("Batch1", length(disp_nonzero_batch1)), 
                                      rep("Batch2", length(disp_nonzero_batch2))),
                              value=do.call(c, disp_nonzero_lst))
ggplot(disp_nonzero_df , aes(x=Batch, y=value)) +
  geom_violin() +
  labs(x="Batch", y="Estimated gene-wise dispersion on NON-ZERO counts", 
       title="Comparison of estimated dispersion across batches") +
  stat_summary(fun.y=mean, colour="darkred", geom="point", shape=18, size=3) #+
  #scale_y_continuous(limits=c(0, 1))
```

**Conclusions:**

+ Mean dispersion of Batch 1 is roughly 2 times that of Batch 2.
+ The maximum absolute value of dispersion are indeed reduced after 0 counts are removed.
+ In this report, dispersion are calculated by different methods before and after removing 0 counts. **Not directly comparable.**
+ We show in another analysis (*CHD8_run_nonzero_disps.R*) that the relationship between two batch did not change much after removing 0s.


### Batch variance with 0 counts removed 

**Median (of all genes)** gene-wise variance after removing zeros: 

```{r, echo=FALSE}
var_tb_rmzero <- matrix(NA, nrow=2, ncol=nlevels(as.factor(batch)), 
                        dimnames=list(c("Controls", "Cases"), paste0("Batch", levels(as.factor(batch)))))
cts_rmzero <- assay(rse_gene,"counts"); cts_rmzero[cts_rmzero==0] <- NA
var_tb_rmzero["Controls", "Batch1"] <- median(rowVars(cts_rmzero[, batch==1&group_num==0], na.rm=TRUE), na.rm=TRUE)
var_tb_rmzero["Controls", "Batch2"] <- median(rowVars(cts_rmzero[, batch==2&group_num==0], na.rm=TRUE), na.rm=TRUE)
var_tb_rmzero["Cases", "Batch1"] <- median(rowVars(cts_rmzero[, batch==1&group_num==1], na.rm=TRUE), na.rm=TRUE)
var_tb_rmzero["Cases", "Batch2"] <- median(rowVars(cts_rmzero[, batch==2&group_num==1], na.rm=TRUE), na.rm=TRUE)
print(round(var_tb_rmzero, 2))
```

Scaled by that of batch 1:

```{r, echo=FALSE}
var_tb_rmzero_scaled <- apply(var_tb_rmzero, 2, function(x){x/var_tb_rmzero[,"Batch1"]})
print(round(var_tb_rmzero_scaled, 2))
```



### Is there a difference in zero portions across batches?

Another question related to batch effect, is whether there is any difference in the percentage of 0 counts in a gene between two batches. 

```{r, echo=FALSE, message=FALSE}
cts <- assay(rse_gene, "counts")

n_zeros_batch1 <- apply(cts[, batch==1], 1, function(x){length(which(x==0))})
percent_zeros_batch1 <- n_zeros_batch1 / sum(batch==1)
n_zeros_batch2 <- apply(cts[, batch==2], 1, function(y){length(which(y==0))})
percent_zeros_batch2 <- n_zeros_batch2 / sum(batch==2)

percent_zeros_batch_df <- data.frame(Batch1=percent_zeros_batch1, Batch2=percent_zeros_batch2)
percent_zeros_batch_df_mlt <- melt(percent_zeros_batch_df, variable.name="Batch")
ggplot(percent_zeros_batch_df_mlt, aes(x=Batch, y=value)) +
  geom_violin() +
  labs(y="Percentage of 0 counts in a single gene") +
  theme(axis.title.x=element_blank())
```

**Conclusions:**

+ There isn't an obvious difference in zero fractions between batches.


### Goodness of fit for NB distribution to non-zero portion of genes

It is difficult to evaluate quantitatively the goodness-of-fit of NB distribution on data. Instead, we generate Q-Q plots for 100 randomly selected genes, comparing data with NB distribution using ML estimated parameters. We generate these plots **within batch 1, for cases and control samples separately**. Figures are stored under {output_dir}/qqplots/.

```{r, echo=FALSE, results="hide"}
if(!dir.exists(file.path(output_dir, "qqplots"))){dir.create(file.path(output_dir, "qqplots"))}
set.seed(1234)
N_sel_nb <- 100
chosen_id_nb <- sample(1:nrow(rse_gene), N_sel_nb, replace=FALSE)
cts_subset_nb <- cts[chosen_id_nb, ]
for(i in 1:N_sel_nb){
  # case samples
  curr_cts <- cts_subset_nb[i, batch==1 & group_num==1]
  curr_cts <- curr_cts[curr_cts!=0]
  if(length(curr_cts) <= 2 | var(curr_cts)==0){next}
  df <- data.frame(y=curr_cts)
  params <- fitdistr(df$y, "negative binomial")$estimate
  
  png(paste0(output_dir, "/qqplots/gene", i, "_cases.png"), 
      width=5, height=5, units="in", res=300)
  print(ggplot(df, aes(sample=y)) +
          stat_qq(distribution=qnbinom, dparams=params) + 
          stat_qq_line(distribution=qnbinom, dparams=params) +
          labs(title="Q-Q plot: Batch 1 cases"))
  dev.off()
  rm(curr_cts, df, params)
  
  # control samples
  curr_cts <- cts_subset_nb[i, batch==1 & group_num==0]
  curr_cts <- curr_cts[curr_cts!=0]
  if(length(curr_cts) <= 2 | var(curr_cts)==0){next}
  df <- data.frame(y=curr_cts)
  params <- fitdistr(df$y, "negative binomial")$estimate
  
  png(paste0(output_dir, "/qqplots/gene", i, "_controls.png"), 
      width=5, height=5, units="in", res=300)
  print(ggplot(df, aes(sample=y)) +
          stat_qq(distribution=qnbinom, dparams=params) + 
          stat_qq_line(distribution=qnbinom, dparams=params) +
          labs(title="Q-Q plot: Batch 1 controls"))
  dev.off()
}
```

<!--
We can also calculate a Pearson correlation between counts and a random sample from NB distribution, with parameters estimated from the real data. We do this for cases and controls separately in batch 1 as well.
-->
```{r, echo=FALSE, eval=FALSE}
case_corr <- ctrl_corr <- c()

for(j in 1:N_sel_nb){
  # case samples
  curr_cts <- cts_subset_nb[j, batch==1 & group_num==1]
  curr_cts <- curr_cts[curr_cts!=0]
  if(length(curr_cts) <= 2 | var(curr_cts)==0){next}
  pars <- fitdistr(curr_cts, "negative binomial")$estimate
  rand_sample <- rnbinom(length(curr_cts), mu=pars["mu"], size=pars["size"])
  curr_cor <- try(cor(as.numeric(curr_cts), rand_sample, method="spearman"))
  if(class(curr_cor)=="try-error"){next}
  case_corr <- c(case_corr, curr_cor)
  rm(curr_cts, pars, rand_sample)
    
  # control samples
  curr_cts <- cts_subset_nb[j, batch==1 & group_num==0]
  curr_cts <- curr_cts[curr_cts!=0]
  if(length(curr_cts) <= 2 | var(curr_cts)==0){next}
  pars <- fitdistr(curr_cts, "negative binomial")$estimate
  rand_sample <- rnbinom(length(curr_cts), mu=pars["mu"], size=pars["size"])
  curr_cor <- try(cor(as.numeric(curr_cts), rand_sample, method="spearman"))
  if(class(curr_cor)=="try-error"){next}
  ctrl_corr <- c(ctrl_corr, curr_cor)
  rm(curr_cts, pars, rand_sample)
}
```



## More justification for having different dispersion parameter for different batches {.tabset}

Finally, a very important assumption of ComBat-seq model (compared to adding batch covariates in linear model of edgeR and DESeq), is that **having a different dispersion parameter for each batch is beneficial for DE performance**. As argued by many of these papers, accurate estimation of dispersion paramters are important for DE detection. As we have seen above, there is some difference in dispersion distribution across batches. If dispersion estimates within each batch and using the whole study are not consistent with each other, then it is justification that we may need different dipsersion parameter for different batches, and it could be good for DE.

<!--
This could also be that dispersion - mean dependence are different in different batches. Therefore, in this section we plot dispersion estimates against mean gene counts, within each batch.
-->

```{r, echo=FALSE, eval=FALSE, results='hide'}
##  Dispersion in batch 1 and 2 (edgeR)
# y_batch1 <- DGEList(counts=cts[, batch==1], group=as.factor(group_num[batch==1]))
# y_batch1 <- calcNormFactors(y_batch1, method="TMM")
# design_batch1 <- model.matrix(~as.factor(group_num[batch==1]))
# y_batch1 <- estimateDisp(y_batch1, design_batch1)
# 
# y_batch2 <- DGEList(counts=cts[, batch==2], group=as.factor(group_num[batch==2]))
# y_batch2 <- calcNormFactors(y_batch2, method="TMM")
# design_batch2 <- model.matrix(~as.factor(group_num[batch==2]))
# y_batch2 <- estimateDisp(y_batch2, design_batch2)


##  Dispersion in batch 1 and 2 (MLE)
# dispMLE_batch1 <- apply(cts[,batch==1], 1, function(x, g1){
#   ff <- try(glm.nb(x~as.factor(g1), control=glm.control(maxit=200)))
#   if(class(ff)[1]!="try-error"){
#     return(1/ff$theta)
#   }
#   return(NA)
# }, g1=group_num[batch==1])


##  Dispersion in batch 1 and 2 (DESeq2)
dds1 <- DESeqDataSetFromMatrix(countData=cts[,batch==1], design=~Group,
                               colData=data.frame(Group=as.factor(group_num[batch==1])))
dds1 <- estimateSizeFactors(dds1)
dds1 <- estimateDispersions(dds1)

dds2 <- DESeqDataSetFromMatrix(countData=cts[,batch==2], design=~Group,
                               colData=data.frame(Group=as.factor(group_num[batch==2])))
dds2 <- estimateSizeFactors(dds2)
dds2 <- estimateDispersions(dds2)


##  Dispersion from whole dataset (including batch as a covariate)
dds <- DESeqDataSetFromMatrix(countData=cts, design=~Group+Batch,
                              colData=data.frame(Group=as.factor(group_num), Batch=as.factor(batch)))
dds <- estimateSizeFactors(dds)
dds <- estimateDispersions(dds)


##  normalized counts
cts_norm_1 <- apply(cts[, batch==1], 2, function(x){x/sum(x)})
cts_norm_2 <- apply(cts[, batch==2], 2, function(y){y/sum(y)})
cts_norm <- apply(cts, 2, function(z){z/sum(z)})


####  Visualize
batch1_stats <- data.frame(Mean=rowMeans(cts_norm_1), Disp=dispersions(dds1)) #Disp=y_batch1$tagwise.dispersion)
batch2_stats <- data.frame(Mean=rowMeans(cts_norm_2), Disp=dispersions(dds2)) #Disp=y_batch2$tagwise.dispersion)
merged_stats <- data.frame(rbind(batch1_stats, batch2_stats), 
                           Batch=as.factor(c(rep("Batch 1", nrow(batch1_stats)), 
                                             rep("Batch 2", nrow(batch2_stats)))))

# disp_mean_batch1 <- ggplot(batch1_stats, aes(x=Mean, y=Dispersion)) +
#   geom_point() +
#   labs(x="Mean", y="Dispersion", title="Batch 1")
# disp_mean_batch2 <- ggplot(batch2_stats, aes(x=Mean, y=Dispersion)) +
#   geom_point() +
#   labs(x="Mean", y="Dispersion", title="Batch 2")
# grid.arrange(disp_mean_batch1, disp_mean_batch2, ncol=2)
p_sep <- ggplot(merged_stats, aes(x=Mean, y=Disp)) +
  facet_grid(~Batch) +
  geom_point() +
  labs(x="mean of normalized counts", y="dispersion estimates") #+
  #scale_x_continuous(limits=c(0,0.0001))

whole_stats <- data.frame(Mean=rowMeans(cts_norm), Disp=dispersions(dds))

p_whole <- ggplot(whole_stats, aes(x=Mean, y=Disp)) +
  geom_point() +
  labs(x="mean of normalized counts", y="dispersion estimates") #+
  #scale_x_continuous(limits=c(0,0.0001))

grid.arrange(p_sep, p_whole, nrow=2)

# disps_1 <- dispersions(dds1)
# disps_2 <- dispersions(dds2)
# disps_whole <- dispersions(dds)
```

Here we generate scatter plots comparing dispersion estimates within each batch to estimates from whole dataset (**including batch as a covariate in whole study**).

```{r, echo=FALSE, results='hide'}
##  Dispersion in batch 1 and 2 & in whole study (including batch as covariate) (edgeR)
y_batch1 <- DGEList(counts=cts[, batch==1], group=as.factor(group_num[batch==1]))
y_batch1 <- calcNormFactors(y_batch1, method="TMM")
design_batch1 <- model.matrix(~as.factor(group_num[batch==1]))
y_batch1 <- estimateDisp(y_batch1, design_batch1)

y_batch2 <- DGEList(counts=cts[, batch==2], group=as.factor(group_num[batch==2]))
y_batch2 <- calcNormFactors(y_batch2, method="TMM")
design_batch2 <- model.matrix(~as.factor(group_num[batch==2]))
y_batch2 <- estimateDisp(y_batch2, design_batch2)

y_whole <- DGEList(counts=cts)
y_whole <- calcNormFactors(y_whole, method="TMM")
design_whole <- model.matrix(~as.factor(group_num)+as.factor(batch))
y_whole <- estimateDisp(y_whole, design_whole)

disp1_gene_edgeR <- y_batch1$tagwise.dispersion
disp2_gene_edgeR <- y_batch2$tagwise.dispersion
dispW_gene_edgeR <- y_whole$tagwise.dispersion

disp1_trend_edgeR <- y_batch1$trended.dispersion
disp2_trend_edgeR <- y_batch2$trended.dispersion
dispW_trend_edgeR <- y_whole$trended.dispersion


##  Dispersion in batch 1 and 2 & in whole study (including batch as covariate) (DESeq2)
dds1 <- DESeqDataSetFromMatrix(countData=cts[,batch==1], design=~Group,
                               colData=data.frame(Group=as.factor(group_num[batch==1])))
dds1 <- estimateSizeFactors(dds1)
dds1 <- estimateDispersions(dds1)

dds2 <- DESeqDataSetFromMatrix(countData=cts[,batch==2], design=~Group,
                               colData=data.frame(Group=as.factor(group_num[batch==2])))
dds2 <- estimateSizeFactors(dds2)
dds2 <- estimateDispersions(dds2)

ddsW <- DESeqDataSetFromMatrix(countData=cts, design=~Group+Batch,
                               colData=data.frame(Group=as.factor(group_num), Batch=as.factor(batch)))
ddsW <- estimateSizeFactors(ddsW)
ddsW <- estimateDispersions(ddsW)

disp1_gene_DESeq2 <- dispersions(dds1)
disp2_gene_DESeq2 <- dispersions(dds2)
dispW_gene_DESeq2 <- dispersions(ddsW)
```

```{r, echo=FALSE, eval=FALSE, results='hide'}
plotDispEsts(ddsW)
```

### Gene-wise dispersion estimates (log10 scale)

```{r, echo=FALSE, results='hide', fig.width=4, fig.height=6}
disps_all <- data.frame(Batch1.edgeR=disp1_gene_edgeR, 
                        Batch2.edgeR=disp2_gene_edgeR, 
                        Whole.edgeR=dispW_gene_edgeR,
                        Batch1.edgeR.trend=disp1_trend_edgeR, 
                        Batch2.edgeR.trend=disp2_trend_edgeR, 
                        Whole.edgeR.trend=dispW_trend_edgeR,
                        Batch1.DESeq2=disp1_gene_DESeq2, 
                        Batch2.DESeq2=disp2_gene_DESeq2, 
                        Whole.DESeq2=dispW_gene_DESeq2)
disps_all_log10 <- log10(disps_all)

plt_range_edgeR <- range(c(disp1_gene_edgeR, disp2_gene_edgeR, dispW_gene_edgeR), na.rm=TRUE)
plt_range_edgeRtrend <- range(c(disp1_trend_edgeR, disp2_trend_edgeR, dispW_trend_edgeR), na.rm=TRUE)
plt_range_DESeq2 <- range(c(disp1_gene_DESeq2, disp2_gene_DESeq2, dispW_gene_DESeq2), na.rm=TRUE)

plt_range_edgeR_log10 <- log10(plt_range_edgeR)
plt_range_edgeRtrend_log10 <- log10(plt_range_edgeRtrend)
plt_range_DESeq2_log10 <- log10(plt_range_DESeq2)

genScatterPlot <- function(df, aes.x, aes.y, method, plt.range){
  p <- ggplot(df, aes(x=df[,aes.x], y=df[,aes.y])) +
  geom_point() +
  geom_abline(slope=1, intercept=0, color="blue", linetype="dashed") +
  labs(title=sprintf("%s, Pearson corr = %s", method,
                     round(cor(df[,aes.x], df[,aes.y], use="pairwise.complete.obs", method="pearson"),2))) +
  scale_x_continuous(limits=plt.range) +
  scale_y_continuous(limits=plt.range)
}

p1W_edgeR <- genScatterPlot(disps_all_log10, aes.x="Whole.edgeR", aes.y="Batch1.edgeR", 
                            method="edgeR", plt.range=plt_range_edgeR_log10) + 
  labs(x="dispersion (log10 scale) - whole dataset", y="dispersion (log10 scale) - batch 1")
p2W_edgeR <- genScatterPlot(disps_all_log10, aes.x="Whole.edgeR", aes.y="Batch2.edgeR", 
                            method="edgeR", plt.range=plt_range_edgeR_log10) +
  labs(x="dispersion (log10 scale) - whole dataset", y="dispersion (log10 scale) - batch 2")
p1v2_edgeR <- genScatterPlot(disps_all_log10, aes.x="Batch1.edgeR", aes.y="Batch2.edgeR", 
                             method="edgeR", plt.range=plt_range_edgeR_log10) +
  labs(x="dispersion (log10 scale) - batch 1", y="dispersion (log10 scale) - batch 2")
 
p1W_DESeq2 <- genScatterPlot(disps_all_log10, aes.x="Whole.DESeq2", aes.y="Batch1.DESeq2", 
                             method="DESeq2", plt.range=plt_range_DESeq2_log10) + 
  labs(x="dispersion (log10 scale) - whole dataset", y="dispersion (log10 scale) - batch 1")
p2W_DESeq2 <- genScatterPlot(disps_all_log10, aes.x="Whole.DESeq2", aes.y="Batch2.DESeq2", 
                             method="DESeq2", plt.range=plt_range_DESeq2_log10) +
  labs(x="dispersion (log10 scale) - whole dataset", y="dispersion (log10 scale) - batch 2")
p1v2_DESeq2 <- genScatterPlot(disps_all_log10, aes.x="Batch1.DESeq2", aes.y="Batch2.DESeq2", 
                              method="DESeq2", plt.range=plt_range_DESeq2_log10) +
  labs(x="dispersion (log10 scale) - batch 1", y="dispersion (log10 scale) - batch 2")

grid.arrange(p1W_edgeR, p1W_DESeq2, p2W_edgeR, p2W_DESeq2, p1v2_edgeR, p1v2_DESeq2, nrow=3, ncol=2)
```

### Trended dispersion estimates (log10 scale)

```{r, echo=FALSE, results='hide', fig.width=4, fig.height=6}
p1W_edgeR <- genScatterPlot(disps_all_log10, aes.x="Whole.edgeR.trend", aes.y="Batch1.edgeR.trend", 
                            method="edgeR trend", plt.range=plt_range_edgeRtrend_log10) + 
  labs(x="dispersion (log10 scale) - whole dataset", y="dispersion (log10 scale) - batch 1")
p2W_edgeR <- genScatterPlot(disps_all_log10, aes.x="Whole.edgeR.trend", aes.y="Batch2.edgeR.trend", 
                            method="edgeR trend", plt.range=plt_range_edgeRtrend_log10) +
  labs(x="dispersion (log10 scale) - whole dataset", y="dispersion (log10 scale) - batch 2")
p1v2_edgeR <- genScatterPlot(disps_all_log10, aes.x="Batch1.edgeR.trend", aes.y="Batch2.edgeR.trend", 
                             method="edgeR trend", plt.range=plt_range_edgeRtrend_log10) +
  labs(x="dispersion (log10 scale) - batch 1", y="dispersion (log10 scale) - batch 2")

grid.arrange(p1W_edgeR, p1W_DESeq2, p2W_edgeR, p2W_DESeq2, p1v2_edgeR, p1v2_DESeq2, nrow=3, ncol=2)
```

## Session info 

```{r, echo=FALSE}
sessionInfo()
```



## References
